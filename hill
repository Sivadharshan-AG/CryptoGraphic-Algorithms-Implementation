Great — below is a self-contained, pure-Python implementation (no NumPy, no heavy built-ins) of the pieces you asked for, written to be simple and readable:

determinant(mat) — determinant of an n x n matrix (recursive Laplace expansion)

egcd(a,b) and modinv(a,m) — extended-GCD and modular inverse (needed to invert det mod 26)

matrix_minor(mat, i, j) — helper to build the minor matrix

matrix_cofactor(mat) → cofactor matrix

matrix_adjugate(mat) → adjugate (transpose of cofactor)

matrix_mod_inv(mat, mod) — inverse of mat modulo mod (returns None if not invertible)

str_to_blocks(text, n) — convert string → list of numeric blocks (each block is a list of length n)

blocks_to_string(blocks) — convert list of numeric blocks → string

All arithmetic for matrix inverse is done modulo 26 (suitable for the Hill cipher).

Copy & paste this into a Python file and run.

# hill_utils.py
# Pure Python (no numpy) helper functions for Hill cipher:
# - determinant (any n x n)
# - modular inverse of matrix mod 26 (if exists)
# - string -> blocks and blocks -> string conversions

ALPHABET_SIZE = 26

# ---------------------------
# Determinant (recursive)
# ---------------------------
def determinant(mat):
    """
    Compute determinant of square matrix mat (list of lists) using Laplace expansion.
    Returns an integer (not reduced modulo anything).
    """
    n = len(mat)
    if n == 0:
        return 1
    if n == 1:
        return mat[0][0]
    if n == 2:
        return mat[0][0]*mat[1][1] - mat[0][1]*mat[1][0]

    det = 0
    for c in range(n):
        # build minor excluding row 0 and column c
        minor = []
        for i in range(1, n):
            row = []
            for j in range(n):
                if j == c:
                    continue
                row.append(mat[i][j])
            minor.append(row)
        sign = -1 if (c % 2 == 1) else 1
        det += sign * mat[0][c] * determinant(minor)
    return det

# ---------------------------
# Extended GCD and modular inverse
# ---------------------------
def egcd(a, b):
    """Extended Euclidean algorithm. Returns (g, x, y) such that a*x + b*y = g = gcd(a,b)"""
    if b == 0:
        return (a, 1, 0)
    else:
        g, x1, y1 = egcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return (g, x, y)

def modinv(a, m):
    """Modular inverse of a modulo m. Returns inverse in 0..m-1, or None if not invertible."""
    a = a % m
    g, x, y = egcd(a, m)
    if g != 1:
        return None  # no inverse
    else:
        return x % m

# ---------------------------
# Matrix minors, cofactors, adjugate
# ---------------------------
def matrix_minor(mat, i, j):
    """Return minor matrix after removing row i and column j"""
    n = len(mat)
    minor = []
    for r in range(n):
        if r == i:
            continue
        row = []
        for c in range(n):
            if c == j:
                continue
            row.append(mat[r][c])
        minor.append(row)
    return minor

def matrix_cofactor(mat):
    """Return cofactor matrix of mat"""
    n = len(mat)
    cof = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            minor = matrix_minor(mat, i, j)
            sign = -1 if ((i + j) % 2 == 1) else 1
            cof[i][j] = sign * determinant(minor)
    return cof

def matrix_transpose(mat):
    n = len(mat)
    return [[mat[j][i] for j in range(n)] for i in range(n)]

def matrix_adjugate(mat):
    """Adjugate = transpose(cofactor matrix)"""
    return matrix_transpose(matrix_cofactor(mat))

# ---------------------------
# Matrix inverse modulo m
# ---------------------------
def matrix_mod_inv(mat, mod=ALPHABET_SIZE):
    """
    Compute inverse of square matrix mat under modulo 'mod'.
    Returns a new matrix where each element is in 0..mod-1.
    If matrix is not invertible mod 'mod', returns None.
    """
    n = len(mat)
    # compute determinant (integer)
    det = determinant(mat)
    det_mod = det % mod
    det_inv = modinv(det_mod, mod)
    if det_inv is None:
        return None  # not invertible modulo mod

    # compute adjugate matrix
    adj = matrix_adjugate(mat)

    # inverse = det_inv * adj (mod mod)
    inv = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            inv[i][j] = (det_inv * adj[i][j]) % mod
    return inv

# ---------------------------
# String <-> Blocks conversions
# ---------------------------
def clean_text(text):
    """Keep only A-Z letters and uppercase them."""
    out = []
    for ch in text:
        if 'A' <= ch <= 'Z' or 'a' <= ch <= 'z':
            out.append(ch.upper())
    return ''.join(out)

def str_to_blocks(text, n):
    """
    Convert plaintext string to list of numeric blocks of size n.
    Each block is a list of integers in 0..25 (A=0..Z=25).
    Pads with 'X' (value 23) if necessary.
    """
    s = clean_text(text)
    values = [ord(ch) - ord('A') for ch in s]
    # pad
    while len(values) % n != 0:
        values.append(ord('X') - ord('A'))
    blocks = []
    for i in range(0, len(values), n):
        blocks.append(values[i:i+n])
    return blocks

def blocks_to_string(blocks):
    """
    Convert list of numeric blocks (each a list of ints 0..25) back to string.
    """
    chars = []
    for block in blocks:
        for v in block:
            chars.append(chr((v % ALPHABET_SIZE) + ord('A')))
    return ''.join(chars)

# ---------------------------
# Example usage
# ---------------------------
if __name__ == "__main__":
    # Example 3x3 key (must be invertible mod 26)
    key3 = [
        [6,24,1],
        [13,16,10],
        [20,17,15]
    ]
    print("Key matrix:")
    for row in key3:
        print(row)

    det_key = determinant(key3)
    print("Determinant (integer):", det_key)
    print("Determinant mod 26:", det_key % 26)

    inv_key3 = matrix_mod_inv(key3, 26)
    if inv_key3 is None:
        print("Key matrix not invertible mod 26")
    else:
        print("Inverse matrix mod 26:")
        for row in inv_key3:
            print(row)

    # Example string <-> blocks
    text = "HELLO WORLD!"
    blocks = str_to_blocks(text, 3)  # for 3x3 key
    print("Blocks:", blocks)
    recovered = blocks_to_string(blocks)
    print("Recovered text:", recovered)

Notes & Guidance

determinant(mat) uses Laplace expansion and is easy to read; for large n it's slow (exponential). For Hill cipher key sizes (2×2 or 3×3) this is perfectly fine.

matrix_mod_inv(mat, 26):

computes the integer determinant,

reduces it modulo 26,

finds modular inverse of determinant mod 26 using extended GCD,

forms adjugate (cofactor transpose),

multiplies adjugate by det_inv modulo 26 to get the modular inverse matrix.

If the determinant is not invertible (i.e., gcd(det_mod, 26) != 1), inverse does not exist and function returns None.

str_to_blocks(..., n) returns blocks as lists ordered left-to-right (i.e., the usual way for Hill cipher: plaintext divided into consecutive n-letter vectors).

blocks_to_string converts blocks back to letters (A..Z). It does not remove padding; if you want to drop trailing X used for padding, trim manually afterwards.
